###### Kent Beck
#best-practices 

___

Modello di sviluppo del software che prevede che la stesura dei test automatici avvenga _prima_ di quella del software che deve essere sottoposto a test, e che lo sviluppo del software applicativo sia orientato _esclusivamente_ all'obiettivo di passare i test automatici precedentemente predisposti.

Prevede un ciclo di sviluppo in 3 fasi:
- **fase rossa**: programmatore scrive test automatici per la nuova funzione da sviluppare. Perché il test sia completo, deve essere eseguibile e, quando viene eseguito, produrre un esito negativo. In molti contesti, questo implica che debba essere realizzato una bozza minimale del codice da testare, necessario per garantire la compilazione e l'esecuzione del test. Una volta che il nuovo test è completo e può essere eseguito, dovrebbe fallire. La fase rossa si conclude quando c'è un nuovo test che può essere eseguito e fallisce.

- **fase verde**: sviluppo della quantità minima di codice necessaria a passare il test. Non è richiesto che il codice scritto sia di buona qualità, elegante, o generale; l'unico obiettivo esplicito è che funzioni, ovvero passi il test. In effetti, è esplicitamente vietato dalla pratica del TDD lo sviluppo di parti di codice non strettamente finalizzate al superamento del test. Quando il codice è pronto, il programmatore esegue nuovamente tutti i test disponibili sul software modificato (non solo quello che precedentemente falliva). In questo modo, il programmatore ha modo di rendersi conto immediatamente se la nuova implementazione ha causato fallimenti di test preesistenti, ovvero ha causato regressioni o peggioramenti nel codice. La fase verde termina quando tutti i test vengono passati con successo.

- **refactoring / fase grigia**: esecuzione del refactoring del codice per adeguarlo a determinati standard di qualità. Quando il software passa tutti i test, il programmatore dedica una certa quantità di tempo a farne _refactoring_, ovvero a migliorarne la struttura attraverso un procedimento basato su piccole modifiche controllate volte a eliminare o ridurre difetti oggettivamente riconoscibili nella struttura interna del codice. Esempi tipici di azioni di refactoring includono la scelta di identificatori più espressivi, eliminazione di codice duplicato, semplificazione e razionalizzazione dell'architettura del sorgente (p.es. in termini della sua organizzazione in classi), e così via. La letteratura sul TDD fornisce numerose linee guida sia specifiche che generali sul modo corretto di fare refactoring. In ogni caso, l'obiettivo del refactoring non è quello di ottenere del codice "perfetto", ma solo di _migliorarne_ la struttura, secondo la cosiddetta "regola dei Boy Scout": "lascia l'area dove ti sei accampato più pulita di come l'hai trovata". Dopo ciascuna azione di refactoring, i test automatici vengono nuovamente eseguiti per accertarsi che le modifiche eseguite non abbiano introdotto errori.